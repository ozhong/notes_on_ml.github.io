{"meta":{"title":"Hexo","subtitle":"","description":"","author":"John Doe","url":"http://example.com","root":"/"},"pages":[],"posts":[{"title":"","slug":"leetcode_summary","date":"2021-06-17T08:09:05.775Z","updated":"2021-06-17T08:14:41.802Z","comments":true,"path":"2021/06/17/leetcode_summary/","link":"","permalink":"http://example.com/2021/06/17/leetcode_summary/","excerpt":"","text":"Leetcode SummaryDFS - Binary Search Tree (BST)keywords: Backtracking, InOrder/PreOrder/PostOrder traversal Validate Binary Search Tree Convert Sorted Array to Binary Search Tree Kth Smallest element in a BST Lowest Common Ancestor of a Binary Search Tree Trim a Binary Search Tree Search Range in Binary Search Tree DFS - Combinations","categories":[],"tags":[]},{"title":"","slug":"leetcode_700","date":"2021-06-17T07:57:02.670Z","updated":"2021-06-17T07:57:17.870Z","comments":true,"path":"2021/06/17/leetcode_700/","link":"","permalink":"http://example.com/2021/06/17/leetcode_700/","excerpt":"","text":"Leetcode 700 - Search in a Binary Search Tree@[DFS|BST|Backtracking|Easy] ProblemGiven BST and value to search, return the node. Solution We use the property of BST and check each node. The idea is similar to binary search Time complexity: O(H). H: height of tree. Average is O(logN) and worst case O(N) Space complexity: same as time complexityCodes - Python123456789101112class Solution: def searchBST(self, root: TreeNode, val: int) -&gt; TreeNode: if root is None: return None if root.val == val: return root if root.val &gt; val: return self.searchBST(root.left, val) if root.val &lt; val: return self.searchBST(root.right, val) return None","categories":[],"tags":[]},{"title":"","slug":"leetcode_669","date":"2021-06-17T07:51:38.805Z","updated":"2021-06-17T07:53:01.451Z","comments":true,"path":"2021/06/17/leetcode_669/","link":"","permalink":"http://example.com/2021/06/17/leetcode_669/","excerpt":"","text":"Leetcode 669 - Trim a Binary Search Tree@[DFS|BST|Backtracking|Medium] ProblemGiven BST, return root node of subtrees which have nodes with values in given range. Solution We use the property of BST and iteratively check if given nodes are on the left and right subtrees respectively. Time complexity: O(N). We visit each node at most once. Space complexity: O(N). The worst case of stack size used in backtracking is size of tree.Codes - Python1234567891011class Solution: def trimBST(self, root: TreeNode, low: int, high: int) -&gt; TreeNode: if root is None: return None if root.val &lt; low: return self.trimBST(root.right, low, high) if root.val &gt; high: return self.trimBST(root.left, low , high) root.left = self.trimBST(root.left, low , root.val) root.right = self.trimBST(root.right, root.val, high) return root","categories":[],"tags":[]},{"title":"","slug":"leetcode_235","date":"2021-06-17T07:43:06.970Z","updated":"2021-06-17T07:43:18.662Z","comments":true,"path":"2021/06/17/leetcode_235/","link":"","permalink":"http://example.com/2021/06/17/leetcode_235/","excerpt":"","text":"Leetcode 235 - Lowest Common Ancestor of a Binary Search Tree@[DFS|BST||Easy] ProblemFind lowest common ancestor in BST. Solution We use the property of BST and iteratively check if given nodes are on the left and right subtrees respectively. Time complexity: O(N) Space complexity: O(1)Codes - Python12345678910class Solution: def lowestCommonAncestor(self, root: &#x27;TreeNode&#x27;, p: &#x27;TreeNode&#x27;, q: &#x27;TreeNode&#x27;) -&gt; &#x27;TreeNode&#x27;: while root: if root.val &gt; p.val and root.val &gt; q.val: root = root.left elif root.val &lt; p.val and root.val &lt; q.val: root = root.right else: return root return None","categories":[],"tags":[]},{"title":"","slug":"leetcode_230","date":"2021-06-17T07:38:06.908Z","updated":"2021-06-17T07:38:34.766Z","comments":true,"path":"2021/06/17/leetcode_230/","link":"","permalink":"http://example.com/2021/06/17/leetcode_230/","excerpt":"","text":"Leetcode 230 - Kth Smallest element in a BST@[DFS|BST|Backtracking|InOrderTraversal|Medium] ProblemConvert a sorted array into a height-balanced BST.A height-balanced binary tree is a tree in which the depth of two subtrees of every node never differs by more than one. Solution We use the property of BST and keep counting size of left subtree. The idea is similar idea to binary search. Time complexity: O(H + k). H: depth of tree Space complexity: O(H + k)Codes - Python123456789101112131415161718class Solution: def kthSmallest(self, root: TreeNode, k: int) -&gt; int: left = self.count_nodes(root.left) # note k is kth smallest, when k == 2, we look for index 1 in array converted from tree if left == k - 1: return root.val elif left &gt; k - 1: return self.kthSmallest(root.left, k) else: return self.kthSmallest(root.right, k - left - 1) def count_nodes(self, root): if root is None: return 0 left = self.count_nodes(root.left) right = self.count_nodes(root.right) return left + right + 1","categories":[],"tags":[]},{"title":"","slug":"leetcode_108","date":"2021-06-17T07:08:37.275Z","updated":"2021-06-17T07:08:50.620Z","comments":true,"path":"2021/06/17/leetcode_108/","link":"","permalink":"http://example.com/2021/06/17/leetcode_108/","excerpt":"","text":"Leetcode 108 - Convert Sorted Array to Binary Search Tree@[DFS|BST|Backtracking|InOrderTraversal|Easy] ProblemConvert a sorted array into a height-balanced BST.A height-balanced binary tree is a tree in which the depth of two subtrees of every node never differs by more than one. Solution Backtracking: Split array at middle and construct left and right subtrees iteratively. Time complexity: O(N) Space complexity: O(logN) Codes - Python12345678910class Solution: def sortedArrayToBST(self, nums: List[int]) -&gt; TreeNode: if len(nums) == 0: return None l, r = 0, len(nums) - 1 mid = l + (r - l) // 2 left = self.sortedArrayToBST(nums[:mid]) right = self.sortedArrayToBST(nums[mid+1:]) root = TreeNode(val = nums[mid], left=left, right=right) return root","categories":[],"tags":[]},{"title":"","slug":"leetcode_98","date":"2021-06-17T04:54:12.336Z","updated":"2021-06-17T06:52:48.469Z","comments":true,"path":"2021/06/17/leetcode_98/","link":"","permalink":"http://example.com/2021/06/17/leetcode_98/","excerpt":"","text":"Leetcode 98 - Validate Binary Search Tree@[DFS|BST|Backtracking|Medium] ProblemCheck if a given binary tree is a valid BST.A valid BST is defined as All nodes in left subtree is smaller than root All nodes in right subtree is greater than root Solution Backtracking: Given a root node check if it’s a BST on left and right subtrees respectively. Note that we need to keep a copy of max and min of nodes’ ancestors for comparison. Time complexity: O(N) Space complexity: O(N) Codes - Python1234567891011121314151617class Solution: def isValidBST(self, root: TreeNode) -&gt; bool: # Note boundary conditions: -2**32 &lt;= Node.val &lt;= 2**31-1 vmin = - 2**32 vmax = 2**32 return self.validate(root, vmin, vmax) def validate(self, root, vmin, vmax): if root is None: return True elif root.val &lt;= vmin: return False elif root.val &gt;= vmax: return False else: # update min and max of ancestors and check if left and right subtrees are valid BST return self.validate(root.left, vmin, root.val) and self.validate(root.right, root.val, vmax)","categories":[],"tags":[]},{"title":"Hello World","slug":"hello-world","date":"2021-06-09T04:08:22.459Z","updated":"2021-06-09T04:08:22.460Z","comments":true,"path":"2021/06/09/hello-world/","link":"","permalink":"http://example.com/2021/06/09/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}],"categories":[],"tags":[]}